import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Pressable,
  Animated,
  Dimensions,
  Alert,
} from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import * as Haptics from 'expo-haptics';

// Components
import { BottomSheet } from '@/components/ui/BottomSheet';
import { Toast } from '@/components/ui/Toast';

// Services
import { process as pipelineProcess } from '@/features/ai/pipeline';
import { useAuth } from '@/contexts/SupabaseAuthContext';
import { useTranslation } from '@/hooks/useTranslation';
import { useGamificationStore } from '@/store/gamificationStore';
import supabaseService from '@/services/supabase';
import { trackAIInteraction, AIEventType } from '@/features/ai/telemetry/aiTelemetry';

// Modern Voice Recording
import { Audio } from 'expo-av';
import * as FileSystem from 'expo-file-system';

const { width } = Dimensions.get('window');

interface VoiceCheckinModernProps {
  isVisible: boolean;
  onClose: () => void;
  onComplete?: () => void;
}

export default function VoiceCheckinModern({
  isVisible,
  onClose,
  onComplete,
}: VoiceCheckinModernProps) {
  console.log('üéôÔ∏è VoiceCheckinModern rendered, isVisible:', isVisible);
  
  const router = useRouter();
  const { user } = useAuth();
  const { t } = useTranslation();
  const { awardMicroReward, updateStreak } = useGamificationStore();

  // Simple Recording State
  const [recordingState, setRecordingState] = useState<'idle' | 'recording' | 'processing'>('idle');
  const [recordingTime, setRecordingTime] = useState(0);
  const [showToast, setShowToast] = useState(false);
  const [toastMessage, setToastMessage] = useState('');
  const [audioRecording, setAudioRecording] = useState<Audio.Recording | null>(null);

  // Animations
  const pulseAnim = useRef(new Animated.Value(1)).current;
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  // Initialize audio
  useEffect(() => {
    Audio.requestPermissionsAsync();
    Audio.setAudioModeAsync({
      allowsRecordingIOS: true,
      playsInSilentModeIOS: true,
    });
  }, []);

  // Animations
  useEffect(() => {
    if (isVisible) {
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
    }
  }, [isVisible]);

  useEffect(() => {
    if (isRecording) {
      // Pulse animation
      Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.2,
            duration: 800,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 800,
            useNativeDriver: true,
          }),
        ])
      ).start();

      // Wave animation
      Animated.loop(
        Animated.timing(waveAnim, {
          toValue: 1,
          duration: 1500,
          useNativeDriver: true,
        })
      ).start();

      // Timer
      timerInterval.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);

      // Auto-stop after 30 seconds max
      autoStopTimeout.current = setTimeout(() => {
        console.log('‚è∞ Auto-stopping recording after 30 seconds');
        if (isRecording) {
          handleRecordPress(); // Use the new force stop logic
        }
      }, 30000);
    } else {
      pulseAnim.stopAnimation();
      waveAnim.stopAnimation();
      pulseAnim.setValue(1);
      waveAnim.setValue(0);
      
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
        timerInterval.current = null;
      }
      if (autoStopTimeout.current) {
        clearTimeout(autoStopTimeout.current);
        autoStopTimeout.current = null;
      }
      setRecordingTime(0);
    }

    return () => {
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
      }
      if (autoStopTimeout.current) {
        clearTimeout(autoStopTimeout.current);
      }
    };
  }, [isRecording]);

  const startRecording = async () => {
    try {
      console.log('‚ñ∂Ô∏è Setting isRecording to true');
      setIsRecording(true);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

      console.log('‚ñ∂Ô∏è Creating recording...');
      const { recording: newRecording } = await Audio.Recording.createAsync(
        Audio.RecordingOptionsPresets.HIGH_QUALITY
      );
      setRecording(newRecording);
      console.log('‚úÖ Recording started successfully');
    } catch (err) {
      console.error('‚ùå Failed to start recording', err);
      setToastMessage('Ses kaydƒ± ba≈ülatƒ±lamadƒ±');
      setShowToast(true);
      setIsRecording(false);
    }
  };

  const stopRecording = async () => {
    console.log('üõë stopRecording called (legacy function - now handled by handleRecordPress)');
    // This function is now legacy - all recording stop logic is in handleRecordPress
    setIsRecording(false);
    setRecordingTime(0);
    
    if (recording) {
      try {
        await recording.stopAndUnloadAsync();
        setRecording(null);
      } catch (error) {
        console.error('Legacy stopRecording error:', error);
        setRecording(null);
      }
    }
  };

  const processAudioFile = async (audioUri: string) => {
    setIsProcessing(true);
    
    try {
      // Mock transcription for demo purposes - replace with actual STT service
      const mockTranscriptions = [
        "Bug√ºn biraz kaygƒ±lƒ±yƒ±m, s√ºrekli aynƒ± d√º≈ü√ºncelere takƒ±lƒ±p kaldƒ±m",
        "Kendimi gergin hissediyorum, nefes almakta zorlanƒ±yorum",
        "Sabahtan beri moralim d√º≈ü√ºk, enerji seviyem √ßok az",
        "Kompulsiyonlarƒ±m bug√ºn daha yoƒüun, kontrol edemiyorum",
        "Zihnimde s√ºrekli olumsuz d√º≈ü√ºnceler d√∂n√ºyor"
      ];
      
      const mockTranscription = mockTranscriptions[Math.floor(Math.random() * mockTranscriptions.length)];
      console.log('üéôÔ∏è Mock transcription:', mockTranscription);
      
      await handleVoiceAnalysis(mockTranscription);
      
    } catch (error) {
      console.error('Audio processing failed:', error);
      setToastMessage('Ses analizi ba≈üarƒ±sƒ±z oldu');
      setShowToast(true);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleVoiceAnalysis = async (text: string) => {
    if (!user?.id || !text) return;

    try {
      const pipelineResult = await pipelineProcess({
        userId: user.id,
        content: text,
        type: 'voice' as const,
        context: {
          source: 'today' as const,
          timestamp: Date.now(),
        }
      });

      console.log('üéØ Voice Analysis Result:', pipelineResult);

      // Save voice checkin
      await supabaseService.saveVoiceCheckin({
        user_id: user.id,
        text: text,
        mood: pipelineResult.voice?.extractedData?.mood || 50,
        trigger: pipelineResult.voice?.extractedData?.trigger || '',
        confidence: pipelineResult.voice?.confidence || 0.5,
        lang: 'tr-TR',
      });

      // Award rewards
      await awardMicroReward('voice_mood_checkin');
      await updateStreak();

      // Track interaction
      await trackAIInteraction(AIEventType.CHECKIN_COMPLETED, {
        type: pipelineResult.voice?.category || 'MOOD',
        mood: pipelineResult.voice?.extractedData?.mood || 50,
      });

      // Show success and navigate
      setToastMessage('Check-in tamamlandƒ±! üéâ');
      setShowToast(true);
      
      setTimeout(() => {
        onClose();
        if (onComplete) onComplete();
      }, 1500);

    } catch (error) {
      console.error('Voice analysis failed:', error);
      setToastMessage('Analiz ba≈üarƒ±sƒ±z oldu, tekrar dene');
      setShowToast(true);
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const handleRecordPress = async () => {
    console.log('üî¥ Record button pressed, isRecording:', isRecording, 'isProcessing:', isProcessing);
    
    if (isRecording) {
      console.log('üõë FORCE STOPPING recording...');
      // Immediately force stop the recording state
      setIsRecording(false);
      setRecordingTime(0);
      
      // Stop all animations
      pulseAnim.stopAnimation();
      waveAnim.stopAnimation();
      pulseAnim.setValue(1);
      waveAnim.setValue(0);
      
      // Clear timers
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
        timerInterval.current = null;
      }
      if (autoStopTimeout.current) {
        clearTimeout(autoStopTimeout.current);
        autoStopTimeout.current = null;
      }
      
      // Stop the actual recording
      if (recording) {
        try {
          await recording.stopAndUnloadAsync();
          const uri = recording.getURI();
          if (uri) {
            // Process in background without blocking UI
            processAudioFile(uri);
          }
        } catch (error) {
          console.error('Error stopping recording:', error);
        }
        setRecording(null);
      }
      
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      console.log('‚úÖ FORCED recording stop completed');
      
    } else {
      console.log('‚ñ∂Ô∏è Starting recording...');
      await startRecording();
    }
  };

  return (
    <>
      <BottomSheet isVisible={isVisible} onClose={onClose}>
        <View style={styles.container}>
          <Animated.View style={{ opacity: fadeAnim }}>
            {/* Header */}
            <Text style={styles.title}>Voice Check-in</Text>
            <Text style={styles.subtitle}>
              Kendini nasƒ±l hissettiƒüini anlatƒ±rsƒ±n, biz de seni anlayƒ±p en iyi desteƒüi saƒülarƒ±z
            </Text>
            
            {/* Example */}
            <View style={styles.exampleContainer}>
              <Text style={styles.exampleLabel}>√ñrnek:</Text>
              <Text style={styles.exampleText}>
                "Bug√ºn biraz kaygƒ±lƒ±yƒ±m, s√ºrekli d√º≈ü√ºnmeye takƒ±lƒ±p kaldƒ±m..."
              </Text>
            </View>

            {/* Voice Recording Button */}
            <View style={styles.recordContainer}>
              <Pressable
                style={[
                  styles.recordButton,
                  isRecording && styles.recordButtonActive,
                  isProcessing && styles.recordButtonProcessing,
                ]}
                onPress={handleRecordPress}
                disabled={false}
              >
                <Animated.View
                  style={[
                    styles.recordButtonInner,
                    {
                      transform: [{ scale: pulseAnim }],
                    },
                  ]}
                >
                  <MaterialCommunityIcons
                    name={isRecording ? 'stop-circle-outline' : 'microphone-outline'}
                    size={32}
                    color="#ffffff"
                  />
                </Animated.View>
              </Pressable>

              {/* Wave Animation */}
              {isRecording && (
                <Animated.View
                  style={[
                    styles.waveContainer,
                    {
                      opacity: waveAnim,
                      transform: [
                        {
                          scale: waveAnim.interpolate({
                            inputRange: [0, 1],
                            outputRange: [1, 2],
                          }),
                        },
                      ],
                    },
                  ]}
                >
                  <View style={styles.wave} />
                  <View style={[styles.wave, styles.wave2]} />
                  <View style={[styles.wave, styles.wave3]} />
                </Animated.View>
              )}
            </View>

            {/* Status */}
            {isRecording && (
              <View style={styles.statusContainer}>
                <View style={styles.recordingIndicator} />
                <Text style={styles.recordingText}>
                  Kaydediyorum ‚Ä¢ {formatTime(recordingTime)}
                </Text>
              </View>
            )}

            {isProcessing && (
              <View style={styles.processingContainer}>
                <MaterialCommunityIcons name="brain" size={20} color="#10B981" />
                <Text style={styles.processingText}>Analiz ediyorum...</Text>
              </View>
            )}

            {/* Instructions */}
            <View style={styles.instructionsContainer}>
              <Text style={styles.instructionsText}>
                {isRecording 
                  ? 'Konu≈ümaya devam et, seni dinliyorum' 
                  : 'Butona bas ve kendini rahat√ßa ifade et'
                }
              </Text>
              
              {/* Debug Info - remove in production */}
              <Text style={{ 
                fontSize: 14, 
                color: isRecording ? '#ef4444' : '#10B981', 
                marginTop: 8, 
                textAlign: 'center',
                fontWeight: 'bold'
              }}>
                {isRecording ? 'üî¥ KAYIT YAPILIYOR' : '‚ö™ KAYIT DURDU'} | Processing: {isProcessing ? 'YES' : 'NO'}
              </Text>
            </View>
          </Animated.View>
        </View>
      </BottomSheet>

      <Toast
        visible={showToast}
        message={toastMessage}
        onHide={() => setShowToast(false)}
        type={toastMessage.includes('ba≈üarƒ±sƒ±z') || toastMessage.includes('hata') ? 'error' : 'success'}
      />
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingHorizontal: 24,
    paddingTop: 20,
    paddingBottom: 40,
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#374151',
    textAlign: 'center',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#6B7280',
    textAlign: 'center',
    lineHeight: 22,
    marginBottom: 24,
  },
  exampleContainer: {
    backgroundColor: '#F9FAFB',
    borderRadius: 12,
    padding: 16,
    marginBottom: 32,
    width: '100%',
    borderLeftWidth: 4,
    borderLeftColor: '#10B981',
  },
  exampleLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#10B981',
    marginBottom: 4,
  },
  exampleText: {
    fontSize: 15,
    color: '#374151',
    fontStyle: 'italic',
    lineHeight: 20,
  },
  recordContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    marginBottom: 24,
  },
  recordButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#10B981',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 8,
    shadowColor: '#10B981',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  recordButtonActive: {
    backgroundColor: '#EF4444',
    shadowColor: '#EF4444',
  },
  recordButtonProcessing: {
    backgroundColor: '#6B7280',
    shadowColor: '#6B7280',
  },
  recordButtonInner: {
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 40,
  },
  waveContainer: {
    position: 'absolute',
    width: 80,
    height: 80,
    justifyContent: 'center',
    alignItems: 'center',
  },
  wave: {
    position: 'absolute',
    width: 80,
    height: 80,
    borderRadius: 40,
    borderWidth: 2,
    borderColor: '#10B981',
    opacity: 0.3,
  },
  wave2: {
    width: 100,
    height: 100,
    borderRadius: 50,
    opacity: 0.2,
  },
  wave3: {
    width: 120,
    height: 120,
    borderRadius: 60,
    opacity: 0.1,
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  recordingIndicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#EF4444',
    marginRight: 8,
  },
  recordingText: {
    fontSize: 16,
    color: '#EF4444',
    fontWeight: '500',
  },
  processingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F0FDF4',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 20,
    marginBottom: 16,
  },
  processingText: {
    marginLeft: 8,
    fontSize: 15,
    color: '#10B981',
    fontWeight: '500',
  },
  instructionsContainer: {
    paddingHorizontal: 20,
  },
  instructionsText: {
    fontSize: 16,
    color: '#6B7280',
    textAlign: 'center',
    lineHeight: 22,
  },
});
